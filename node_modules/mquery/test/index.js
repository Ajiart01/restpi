'use strict';

const mquery = require('../');
const assert = require('assert');

/* global Map */

describe('mquery', function() {
  let col;

  before(function(done) {
    // get the env specific collection interface
    require('./env').getCollection(function(err, collection) {
      assert.ifError(err);
      col = collection;
      done();
    });
  });

  after(function(done) {
    require('./env').dropCollection(done);
  });

  describe('mquery', function() {
    it('is a function', function() {
      assert.equal('function', typeof mquery);
    });
    it('creates instances with the `new` keyword', function() {
      assert.ok(mquery() instanceof mquery);
    });
    describe('defaults', function() {
      it('are set', function() {
        const m = mquery();
        assert.strictEqual(undefined, m.op);
        assert.deepEqual({}, m.options);
      });
    });
    describe('criteria', function() {
      it('if collection-like is used as collection', function() {
        const m = mquery(col);
        assert.equal(col, m._collection.collection);
      });
      it('non-collection-like is used as criteria', function() {
        const m = mquery({ works: true });
        assert.ok(!m._collection);
        assert.deepEqual({ works: true }, m._conditions);
      });
    });
    describe('options', function() {
      it('are merged when passed', function() {
        let m;
        m = mquery(col, { w: 'majority' });
        assert.deepEqual({ w: 'majority' }, m.options);
        m = mquery({ name: 'mquery' }, { w: 'majority' });
        assert.deepEqual({ w: 'majority' }, m.options);
      });
    });
  });

  describe('toConstructor', function() {
    it('creates subclasses of mquery', function() {
      const opts = { safe: { w: 'majority' }, readPreference: 'p' };
      const match = { name: 'test', count: { $gt: 101 } };
      const select = { name: 1, count: 0 };
      const update = { $set: { x: true } };
      const path = 'street';

      const q = mquery().setOptions(opts);
      q.where(match);
      q.select(select);
      q.updateOne(update);
      q.where(path);
      q.find();

      const M = q.toConstructor();
      const m = M();

      assert.ok(m instanceof mquery);
      assert.deepEqual(opts, m.options);
      assert.deepEqual(match, m._conditions);
      assert.deepEqual(select, m._fields);
      assert.deepEqual(update, m._update);
      assert.equal(path, m._path);
      assert.equal('find', m.op);
    });
  });

  describe('setOptions', function() {
    it('calls associated methods', function() {
      const m = mquery();
      assert.equal(m._collection, null);
      m.setOptions({ collection: col });
      assert.equal(m._collection.collection, col);
    });
    it('directly sets option when no method exists', function() {
      const m = mquery();
      assert.equal(m.options.woot, null);
      m.setOptions({ woot: 'yay' });
      assert.equal(m.options.woot, 'yay');
    });
    it('is chainable', function() {
      const m = mquery();
      let n;

      n = m.setOptions();
      assert.equal(m, n);
      n = m.setOptions({ x: 1 });
      assert.equal(m, n);
    });
  });

  describe('collection', function() {
    it('sets the _collection', function() {
      const m = mquery();
      m.collection(col);
      assert.equal(m._collection.collection, col);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.collection(col);
      assert.equal(m, n);
    });
  });

  describe('$where', function() {
    it('sets the $where condition', function() {
      const m = mquery();
      function go() {}
      m.$where(go);
      assert.ok(go === m._conditions.$where);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.$where('x');
      assert.equal(m, n);
    });
  });

  describe('where', function() {
    it('without arguments', function() {
      const m = mquery();
      m.where();
      assert.deepEqual({}, m._conditions);
    });
    it('with non-string/object argument', function() {
      const m = mquery();

      assert.throws(function() {
        m.where([]);
      }, /path must be a string or object/);
    });
    describe('with one argument', function() {
      it('that is an object', function() {
        const m = mquery();
        m.where({ name: 'flawed' });
        assert.strictEqual(m._conditions.name, 'flawed');
      });
      it('that is a query', function() {
        const m = mquery({ name: 'first' });
        const n = mquery({ name: 'changed' });
        m.where(n);
        assert.strictEqual(m._conditions.name, 'changed');
      });
      it('that is a string', function() {
        const m = mquery();
        m.where('name');
        assert.equal('name', m._path);
        assert.strictEqual(m._conditions.name, undefined);
      });
    });
    it('with two arguments', function() {
      const m = mquery();
      m.where('name', 'The Great Pumpkin');
      assert.equal('name', m._path);
      assert.strictEqual(m._conditions.name, 'The Great Pumpkin');
    });
    it('is chainable', function() {
      const m = mquery();

      let n = m.where('x', 'y');
      assert.equal(m, n);
      n = m.where();
      assert.equal(m, n);
    });
  });
  describe('equals', function() {
    it('must be called after where()', function() {
      const m = mquery();
      assert.throws(function() {
        m.equals();
      }, /must be used after where/);
    });
    it('sets value of path set with where()', function() {
      const m = mquery();
      m.where('age').equals(1000);
      assert.deepEqual({ age: 1000 }, m._conditions);
    });
    it('is chainable', function() {
      const m = mquery();
      const n = m.where('x').equals(3);
      assert.equal(m, n);
    });
  });
  describe('eq', function() {
    it('is alias of equals', function() {
      const m = mquery();
      m.where('age').eq(1000);
      assert.deepEqual({ age: 1000 }, m._conditions);
    });
  });
  describe('or', function() {
    it('pushes onto the internal $or condition', function() {
      const m = mquery();
      m.or({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$or);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.or(arg);
      assert.deepEqual(arg, m._conditions.$or);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.or(arg);
      m.or({ y: 1 });
      m.or([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$or);
    });
    it('is chainable', function() {
      const m = mquery();
      m.or({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $or: [{ o: 'k' }] }, m._conditions);
    });
  });

  describe('nor', function() {
    it('pushes onto the internal $nor condition', function() {
      const m = mquery();
      m.nor({ 'Nightmare Before Christmas': true });
      assert.deepEqual([{ 'Nightmare Before Christmas': true }], m._conditions.$nor);
    });
    it('allows passing arrays', function() {
      const m = mquery();
      const arg = [{ 'Nightmare Before Christmas': true }, { x: 1 }];
      m.nor(arg);
      assert.deepEqual(arg, m._conditions.$nor);
    });
    it('allows calling multiple times', function() {
      const m = mquery();
      const arg = [{ looper: true }, { x: 1 }];
      m.nor(arg);
      m.nor({ y: 1 });
      m.nor([{ w: 'oo' }, { z: 'oo' }]);
      assert.deepEqual([{ looper: true }, { x: 1 }, { y: 1 }, { w: 'oo' }, { z: 'oo' }], m._conditions.$nor);
    });
    it('is chainable', function() {
      const m = mquery();
      m.nor({ o: 'k' }).where('name', 'table');
      assert.deepEqual({ name: 'table', $nor: [{ o: 'k' }] }, m._conditions);
    });
  });

  describe('a